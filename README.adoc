= Ploigos Software Factory Operator

This operator powers OpenShift-based deployments of https://ploigos.github.io/ploigos-docs/[Ploigos] - a DevSecOps ecosystem modeled after the US DoD's https://dodcio.defense.gov/Portals/0/Documents/DoD%20Enterprise%20DevSecOps%20Reference%20Design%20v1.0_Public%20Release.pdf?ver=2019-09-26-115824-583[DoD Enterprise DevSecOps Reference Design(DEDSORD)]. Pipeline steps are implemented using the https://github.com/ploigos/ploigos-step-runner[ploigos-step-runner], a python-based abstraction layer equipped with _step implementers_ that enable agnosticity with underlying tools and services.

Two APIs are offered:

* *TsscPlatform*: an all-in-one resource for provisioning pre-wired infrastructure like a CI tool, static code analysis server, artifact repository, and other services that support a DevSecOps pipeline. 
* *TsscPipeline*: a resource for creating an end-to-end pipeline for your application's source code.

== Quick Start

1. Create a `CatalogSource` to import the RedHatGov operator catalog.

  oc apply -f - << EOF
  apiVersion: operators.coreos.com/v1alpha1
  kind: CatalogSource
  metadata:
    name: redhatgov-operators
    namespace: openshift-marketplace
  spec:
    sourceType: grpc
    image: quay.io/redhatgov/operator-catalog:latest
    displayName: Red Hat NAPS Community Operators
    publisher: RedHatGov
  EOF

2. Create a project for your pipeline tooling to live.

  oc new-project devsecops

3. Ploigos is hungry - delete any `LimitRange` that might have been created from project templates:

  oc delete limitrange --all -n devsecops

4. Create a `TsscPlatform` to spin up your infrastructure:

  oc apply -f - << EOF
  apiVersion: redhatgov.io/v1alpha1
  kind: TsscPlatform
  metadata:
    name: tsscplatform
  spec:
    tsscPlatform:
      helmRepository: 'https://ploigos.github.io/ploigos-charts'
      services:
        artifactRepository:
          managed: true
          name: nexus
        containerRegistry:
          managed: true
          name: nexus
        continuousDeployment:
          managed: true
          name: argocd
        continuousIntegration:
          managed: true
          name: jenkins
        sourceControl:
          managed: true
          name: gitea
        staticCodeAnalysis:
          managed: true
          name: sonarqube
        uat:
          managed: true
          name: selenium
  EOF

5. Then create a `TsscPipeline` instance for our reference application:

  oc apply -f - << EOF
  apiVersion: redhatgov.io/v1alpha1
  kind: TsscPipeline
  metadata:
    name: tsscpipeline-reference-app
  spec:
    appName: ref-quarkus-mvn-jenkins-std
    appRepo:
      destinationRepoName: reference-quarkus-mvn_jenkins_workflow-standard
      sourceUrl: >-
        http://gitea.tssc.rht-set.com/akrohg/reference-quarkus-mvn_jenkins_workflow-standard.git
    autoStartPipeline: true
    helmRepo:
      destinationRepoName: reference-quarkus-mvn-cloud-resources_jenkins_workflow-standard
      sourceUrl: >-
        http://gitea.tssc.rht-set.com/akrohg/reference-quarkus-mvn-cloud-resources_jenkins_workflow-standard.git
    serviceName: fruit
  EOF

6. Watch the magic happen - pop into Jenkins and checkout the pipeline:

  oc get route jenkins --template "https://{{.spec.host}}"

== Optional Configuration

=== Services

You can configure a select number of services in the `tsscPlatform.services` property of your `TsscPlatform` object. 

* The `managed` attribute indicates whether the applicable service should be provisioned by this operator. If `false`, it is assumed to already exist so no action is taken. In the future, we may develop capability to configure existing tooling. 

* The `name` attributes indicates the provider for each service. See below for supported services, with defaults appearing in *bold*.

|===========================
|Service|Required?|Options
|Continuous Integration|✅ a|
* *jenkins*
* tekton
|Source Control|✅ a|
* *gitea*
|Artifact Repository|✅ a|
* *nexus*
|Static Code Analysis|✅ a|
* *sonarqube*
|Container Registry|✅ a|
* *nexus*
* quay
|Continuous Deployment|✅ a|
* *argocd*
|User Acceptance Testing|✅ a|
* *selenium*
|Chat Server| a|
* *matttermost*
|IDE| a|
* *codeready*
|===========================

=== TLS
The default `TsscPlatform` deployment assumes that your OpenShift Router is equipped with a certificate signed by a well-known certificate authority. If your cluster uses self-signed certificates, you'll need to disable TLS verification on your `TsscPlatform` CR like this:

  apiVersion: redhatgov.io/v1alpha1
  kind: TsscPlatform
  metadata:
    name: tsscplatform
  spec:
    tls:
      verify: false

If your certificates are signed using a private CA, you can instead provide the name of a `ConfigMap` which holds your trusted CA Bundle. The ConfigMap should have a single key named ca-bundle.crt. This key has a collection of CA certificates as its value. If the provided ConfigMap exists, it will be used as-is. Otherwise, it will be generated using a label of `config.openshift.io/inject-trusted-cabundle=true` and populated with the *Cluster Network Operator*. For example:

  apiVersion: redhatgov.io/v1alpha1
  kind: TsscPlatform
  metadata:
    name: tsscplatform
  spec:
    tls:
      trustBundleConfigMap: trustedcabundle

== Building the Operator

There is a script `hack/operate.sh` which will download the prerequisites (operator-sdk etc.), build the operator artifacts from operator-sdk defaults, package and push the operator container image, deploy the artifacts to a Kubernetes cluster, and create a `kind: TsscPlatform` CR to deploy an instance. You should use the help page to look at what the various options do, but for the most part if you want to deploy a Tssc Platform to a cluster directly from this repo you could run `hack/operate.sh -d`.

Before running the script make sure to update the location of the container image to a repository you have access to. If you decide to build your own container image for the operator, make sure to update `hack/operate.conf` with an updated container image location and add the `-p` flag to `operate.sh`.

== Developer Installation Steps

The installation of the Custom Resource Definition and Cluster Role requires *cluster-admin* privileges. After that regular users with `admin` privileges on their projects (which is automatically granted to the user who creates a project) can provision the Tssc Operator in their projects and deploy TsscPlatforms using the tsscplatform.redhatgov.io Custom Resource. If you've installed the operator from the https://github.com/RedHatGov/operator-catalog[RedHatGov Operator Catalog Index] on an OLM-enabled cluster, the Tssc operator can be installed from the OperatorHub interface of the console.

Perform the following tasks as *cluster-admin*:

. Deploy the CustomResourceDefinition, ClusterRole, ClusterRoleBinding, ServiceAccount, and Operator Deployment:
+
[source,sh]
----
hack/operate.sh
----

. Once the Operator pod is running the Operator is ready to start creating Tssc Platforms.
. To deploy the above, and also one of the `config/samples/redhatgov_v1alpha1_tsscplatform*.yaml` example CustomResources:
+
[source,sh]
----
hack/operate.sh --deploy-cr
----

. To install the operator with RBAC scoped to a specific namespace, deploying a Role and RoleBinding instead of a ClusterRole and ClusterRoleBinding:
+
[source,sh]
----
hack/operate.sh --overlay=namespaced --namespace=mynamespace
----

== Developer Uninstalling the Tssc Operator

In case you wish to uninstall the Tssc Operator, simply delete the operator and its resources with:

[source,sh]
----
hack/operate.sh -r
----

OLM uninstallation for OLM-based operators can be handled through the UI, or by deleting the `Subscription`.

== Notes on disconnected installations

The Operator SDK makes heavy use of Kustomize for development and installation, but intends bundles to be generated for use in an operator catalog. This enables the Operator Lifecycle Manager, deployed onto your cluster, to install and configure operators with a simple `kind: Subscription` object, instead of a large collection of manifests.

If you are using a `registries.conf` change and/or ImageContentSourcePolicy mirror that covers quay.io/redhatgov images, you should not have to change anything.

To change the image sources for all necessary images to deploy the operator without such a policy, you need to have the following images hosted in a container repository on your disconnected network:

* quay.io/redhatgov/tssc-operator:latest

If you intend on using `hack/operate.sh` it expects you to be in a development environment. Operator installation from this script therefore expects access to the internet. This comes with one extra concern: If `kustomize` isn't in your path, it tries to download it from the internet and save it locally into a `.gitignore`d folder. If you intend on using `hack/operate.sh` to install the operator, you should also bring `kustomize` and place it in the `$PATH` of the user who will be running the script. Additionally, in order to install the operator with `hack/operate.sh` you'll need to make the following change:

* `hack/operate.conf`: IMG should point to the tssc-operator image in your environment

== Contributing
Please see the link:CONTRIBUTING.adoc[Contributing Documentation].
